CalcSin(int, double):
        push    {r7} // сначала sp -= 4; помещение регистра r7 на вершину стека.
        sub     sp, sp, #52 // sp = sp - 52.
        add     r7, sp, #0 // r7 = sp + 0.
        str     r0, [r7, #12] // в регистр r0 загружается значение, лежащее по адресу (r7 + 12) [number].
        vstr.64 d0, [r7] // по адресу (r7) помещается значение из регистра d0 [argument].
        mov     r2, #0 // в регистр r2 копируется значение 0.
        mov     r3, #0 // в регистр r3 копируется значение 0.
        strd    r2, [r7, #40] // по адресу (r7 + 40) помещается значение из регистра r2 [result = 0].
        movs    r3, #1 // в регистр r3 копируется значение 1.
        str     r3, [r7, #36] // по адресу (r7 + 36) помещается значение из регистра r3 [signStatus = 1].
        mov     r2, #0 // в регистр r2 копируется значение 0.
        mov     r3, #0 // в регистр r3 копируется значение 0.
        movt    r3, 16368 // записывает в регистр r3 по битам [16:31] число 16368 [подробный перевод ниже].
        strd    r2, [r7, #24] // по адресу (r7 + 24) помещается значение из регистра r2 [nextMultiplier = 1] [помещает значения из r2 и r3 в память].
        movs    r3, #1 // в регистр r3 копируется значение 1.
        str     r3, [r7, #20] // по адресу (r7 + 20) помещается значение из регистра r2 [factorial = 1].
        movs    r3, #0 // в регистр r3 копируется значение 0.
        str     r3, [r7, #16] // по адресу (r7 + 16) помещается значение из регистра r3 [i = 0].
        b       .L2 // переход на метку .L2.
.L3:
        ldr     r3, [r7, #20] // в r3 загружается значение, лежащее по адресу (r7 + 20) [factorial].
        vmov    s15, r3 @ int // в регистр s15 копируется 32-битное значение из r3 [factorial].
        vcvt.f64.s32    d17, s15 // в d17 записывается (double) s15 (преобразование одинарной точности в двойную).
        vldr.64 d18, [r7] // в регистр d18 загружается значение, лежащее по адресу (r7) [argument].
        vdiv.f64        d16, d18, d17 // d16 = d18 / d17 [argument / factorial].
        vldr.64 d17, [r7, #24] // в d17 загружается значение, лежащее по адресу (r7 + 24) [новый nextMultiplier].
        vmul.f64        d16, d17, d16 // d16 = d17 * d16 [(argument / factorial) * nextMultiplier] (умножение double'ов).
        vstr.64 d16, [r7, #24] // по адресу (r7 + 24) помещается значение d16 [(argument / factorial) * nextMultiplier].
        ldr     r3, [r7, #20] // в r3 загружается значение, лежащее по адресу (r7 + 20) [factorial].
        adds    r3, r3, #1 // r3 = r3 + 1 [factorial += 1].
        str     r3, [r7, #20] // по адресу (r7 + 20) помещается значение r3 [новый factorial].
        ldr     r3, [r7, #36] // в r3 загружается значение, лежащее по адресу (r7 + 36) [signStatus].
        vmov    s15, r3 @ int // в регистр s15 копируется 32-битное значение из r3 [signStatus].
        vcvt.f64.s32    d17, s15 // в d17 записывается (double) s15 (преобразование одинарной точности в двойную).
        vldr.64 d16, [r7, #24] // в регистр d16 загружается значение, лежащее по адресу (r7 + 24) [nextMultiplier].
        vmul.f64        d16, d17, d16 // d16 = d17 * d16 [signStatus * nextMultiplier].
        vldr.64 d17, [r7, #40] // в регистр d17 загружается значение, лежащее по адресу (r7 + 40) [result].
        vadd.f64        d16, d17, d16 // d16 = d17 + d16 [result + signStatus * nextMultiplier].
        vstr.64 d16, [r7, #40] // по адресу (r7 + 40) помещается значение из d16 [новый result].
        ldr     r3, [r7, #20] // в r3 загружается значение, лежащее по адресу (r7 + 20) [factorial].
        vmov    s15, r3 @ int // в регистр s15 копируется 32-битное значение из r3 [factorial].
        vcvt.f64.s32    d17, s15 // в d17 записывается (double) s15 (преобразование одинарной точности в двойную).
        vldr.64 d18, [r7] // в регистр d18 загружается значение, лежащее по адресу (r7) [argument].
        vdiv.f64        d16, d18, d17 // d16 = d18 / d17 [argument / factorial].
        vldr.64 d17, [r7, #24] // в регистр d17 загружается значение, лежащее по адресу (r7 + 24) [nextMultiplier].
        vmul.f64        d16, d17, d16 // d16 = d17 * d16 [(argument / factorial) * nextMultiplier].
        vstr.64 d16, [r7, #24] // по адресу (r7 + 24) помещается значение из d16 [новый nextMultiplier].
        ldr     r3, [r7, #20] // в r3 загружается значение, лежащее по адресу (r7 + 20) [factorial].
        adds    r3, r3, #1 // r3 = r3 + 1 [factorial += 1].
        str     r3, [r7, #20] // по адресу (r7 + 20) помещается значение r3 [новый factorial].
        ldr     r3, [r7, #36] // в r3 загружается значение, лежащее по адресу (r7 + 36) [signStatus].
        rsbs    r3, r3, #0 // r3 = 0 - r3 (reverse substract) [signStatus *= -1].
        str     r3, [r7, #36] // по адресу (r7 + 36) помещается значение r3 [новый signStatus].
        ldr     r3, [r7, #16] // в r3 загружается значение, лежащее по адресу (r7 + 16) [i].
        adds    r3, r3, #1 // r3 = r3 + 1 [i += 1].
        str     r3, [r7, #16] // по адресу (r7 + 16) помещается значение r3 [новое значение i].
.L2:
        ldr     r2, [r7, #16] // в r2 загружается значение, лежащее по адресу (r7 + 16) [i].
        ldr     r3, [r7, #12] // в r3 загружается значение, лежащее по адресу (r7 + 12) [number].
        cmp     r2, r3 // сравнение i и number: (i - number = 0) [обновление флагов].
        blt     .L3 // если i < number, то переход на метку .L3.
        ldrd    r2, [r7, #40] // в регистр r2 загружается значение, лежащее по адресу (r7 + 40) [32 бита result],
                              // в регистр r3 загружается значение, лежащее по адресу (r7 + 44) [еще 32 бита result].
        vmov    d16, r2, r3 // в регистр d16 копируются значения из r2 [0:31] и r3 [32:63].
        vmov.f64        d0, d16 // в регистр d0 копируется значение из d16 [result].
        adds    r7, r7, #52 // r7 = r7 + 52.
        mov     sp, r7 // в sp копируется r7.
        ldr     r7, [sp], #4 // в r7 загружается значение, лежащее по адресу (sp).
        bx      lr // возврат из функции.
.LC0:
        .ascii  "too few arguments. try again\000"
.LC1:
        .ascii  "too many arguments. try again\000"
.LC2:
        .ascii  "%lf\012\000"
.LC3:
        .ascii  "(clock_gettime) total time: %lf sec.\012\000"
main:
        push    {r7, lr} // сначала sp -= 8; помещение lr и r7 на стек.
        sub     sp, sp, #40 // sp = sp - 40.
        add     r7, sp, #0 // r7 = sp + 0.
        str     r0, [r7, #4] // по адресу (r7 + 4) помещается значение, лежащее в r0 [argc].
        str     r1, [r7] // по адресу (r7) помещается значение, лежащее в r1 [argv].
        ldr     r3, [r7, #4] // в регистр r3 загружается значение, лежащее по адресу (r7 + 4) [argc].
        cmp     r3, #2 // сравнение значения из r3 [argc] со значением 2 [обновление флагов] [argc - 2 == 0].
        bgt     .L6 // если argc > 2, то переход на метку .L6 [Z == 0 && V == N].
        movw    r0, #:lower16:.LC0 // записывает в регистр r0 [0:15] (16 бит) 32-битного значения.
        movt    r0, #:upper16:.LC0 // записывает в регистр r0 [16:31] (16 бит) 32-битного значения.
        bl      puts // вызов функции puts; в lr помещается адрес возврата.
        movs    r3, #0 // в регистр r3 помещается число 0 [код возврата из функции main] + обновление флагов.
        b       .L9 // переход на метку .L9.
.L6:
        ldr     r3, [r7, #4] // в регистр r3 загружается значение, лежащее по адресу (r7 + 4) [argc].
        cmp     r3, #3 // сравнение значения из r3 [argc] и 3. [обновление флагов] [argc - 3 == 0].
        ble     .L8 // если argc <= 3 [Z == 1 || N != V], то переход на метку .L8.
        movw    r0, #:lower16:.LC1 // записывает в регистр r0 [0:15] (16 бит) 32-битного значения.
        movt    r0, #:upper16:.LC1 // записывает в регистр r0 [16:31] (16 бит) 32-битного значения.
        bl      puts // вызов функции puts; в lr помещается адрес возврата.
        movs    r3, #0 // в регистр r3 помещается число 0 [код возврата из функции main] + обновление флагов.
        b       .L9 // переход на метку .L9.
.L8:
        ldr     r3, [r7] // в регистр r3 загружается значение [32 бита], лежащее по адресу (r7) [argv].
        adds    r3, r3, #4 // r3 = r3 + 4 [argv[0] + 4 = argv[1]].
        ldr     r3, [r3] // разыменование указателя, теперь тут argv[1].
        movs    r2, #10 // в регистр r2 копируется значение 10.
        movs    r1, #0 // в регистр r1 копируется значение 0 [NULL].
        mov     r0, r3 // в регистр r0 копируется значение из регистра r3 [argv[1]].
        bl      strtol // вызов функции strtol.
        str     r0, [r7, #36] // по адресу (r7 + 36) помещается значение из r0 [number -> результат работы strtol].
        ldr     r3, [r7] // в регистр r3 загружается значение, лежащее по адресу (r7) [argv].
        adds    r3, r3, #8 // r3 = r3 + 8 [argv[0] + 8 = argv[2]].
        ldr     r3, [r3] // разыменование указателя, теперь тут argv[2].
        movs    r1, #0 // в регистр r1 копируется значение 0.
        mov     r0, r3 // в регистр r0 копируется значение из r3 [argv[2]].
        bl      strtod // вызов функции strtod.
        vstr.64 d0, [r7, #24] // по адресу (r7 + 24) помещается значение из d0 [argument -> результат работы strtod].
                              // здесь .64 - спецификатор размера данных для 64-битного доступа к памяти.
        add     r3, r7, #16 // r3 = r7 + 16 [адрес start_clock].
        mov     r1, r3 // в r1 копируется значение из регистра r3 [адрес start_clock].
        movs    r0, #4 // в r0 копируется значение 4 (CLOCK_MONOTONIC_RAW).
        bl      clock_gettime // вызов функции clock_gettime.
        vldr.64 d16, [r7, #24] // в регистр d16 загружается значение, лежащее по адресу (r7 + 24) [argument].
        vldr.64 d17, .L10 // в регистр d17 загружается значение, лежащее по метке .L10 [0.017453].
        vmul.f64        d16, d16, d17 // d16 = d16 * d17 (векторное умножение) [argument * 0.017453].
        vmov.f64        d0, d16 // в регистр d0 копируется значение из d16 [argument * 0.017453].
        ldr     r0, [r7, #36] // в регистр r0 загружается значение, лежащее по адресу (r7 + 36) [number].
        bl      CalcSin(int, double) // вызов функции CalcSin.
        vmov    r2, r3, d0 // в регистре r2 будут [0:31] биты d0, в r3 - [32:63] [результат выполнения функции].
        movw    r0, #:lower16:.LC2 // записывает в регистр r0 [0:15] (16 бит) 32-битного значения.
        movt    r0, #:upper16:.LC2 // записывает в регистр r0 [16:31] (16 бит) 32-битного значения.
        bl      printf // вызов функции printf.
        add     r3, r7, #8 // r3 = r7 + 8 [адрес end_clock].
        mov     r1, r3 // в r1 копируется значение из r3 [адрес end_clock].
        movs    r0, #4 // в r0 копируется значение 4 (CLOCK_MONOTONIC_RAW).
        bl      clock_gettime // вызов функции clock_gettime.
        ldr     r2, [r7, #8] // в r2 загружается значение, лежащее по адресу (r7 + 8) [end_clock.tv_sec].
        ldr     r3, [r7, #16] // в r3 загружается значение, лежащее по адресу (r7 + 16) [start_clock.tv_sec].
        subs    r3, r2, r3 // r3 = r2 - r3 [end_clock.tv_sec - start_clock.tv_sec].
        vmov    s15, r3 @ int // в регистр s15 копируется значение из r3 [разность секунд].
        vcvt.f64.s32    d17, s15 // в d17 записывается (double) s15 (преобразование одинарной точности в двойную).
        ldr     r2, [r7, #12] // в r2 загружается значение, лежащее по адресу (r7 + 8) [end_clock.tv_nsec].
        ldr     r3, [r7, #20] // в r3 загружается значение, лежащее по адресу (r7 + 8) [start_clock.tv_nsec].
        subs    r3, r2, r3 // r3 = r2 - r3 [разность наносекунд].
        vmov    s15, r3 @ int // в регистр s15 копируется значение из r3 [разность наносекунд].
        vcvt.f64.s32    d16, s15 // в d16 записывается (double) s15 (преобразование одинарной точности в двойную).
        vldr.64 d18, .L10+8 // в d18 загружается значение, лежащее по адресу (.L10 + 8) [0.000000001].
        vmul.f64        d16, d16, d18 // d16 = d16 * d18 (разность наносекунд домножается на 0.000000001).
        vadd.f64        d16, d17, d16 // d16 = d17 + d16 (сложили разность секунд с новой разностью наносекунд) [итоговое время].
        vmov    r2, r3, d16 // в регистре r2 будут [0:31] биты d16, в r3 - [32:63] [итоговое время].
        movw    r0, #:lower16:.LC3 // записывает в регистр r0 [0:15] (16 бит) 32-битного значения.
        movt    r0, #:upper16:.LC3 // записывает в регистр r0 [16:31] (16 бит) 32-битного значения.
        bl      printf // вызов функции printf.
        movs    r3, #0 // в r3 копируется значени 0 (код возврата из функции main).
.L9:
        mov     r0, r3 // копирует значение из r3 [код возврата из функции main] в r0.
        adds    r7, r7, #40 // r7 = r7 + 40.
        mov     sp, r7 // копирует значение из r7 в sp.
        pop     {r7, pc} // извлекает со стека два значения и помещает их в r7 и pc; затем sp += 8.
.L10:
        .word   14568529 // 00000000110111100100110001010001 [1] {это для 0.017453}
        .word   1066524467 // 00111111100100011101111100110011 [0] {это для 0.017453}

        .word   -400107883 // 11101000001001101101011010010101 [1] {это для 0.000000001}
        .word   1041313291 // 00111110000100010010111000001011 [0] {это для 0.000000001}

// <используется little-endian>
// [после занесения 16368] в r3: 0000000000000000 0000000000000000 0000000000000000 0011111111110000
// 0 01111111111 0000000000000000000000000000000000000000000000000000 = (-1)^(0) * 2^(1023 - 1023) * 1.0000000000000000000000000000000000000000000000000000 = 1.

// {0.000000001}:
// 0 01111111001 0001110111110011001100000000110111100100110001010001 = (-1)^(0) * 2^(1017 - 1023) * 1.0001110111110011001100000000110111100100110001010001 = 0.017453.

// {0.000000001}:
// 0 01111100001 0001001011100000101111101000001001101101011010010101 = (-1)^(0) * 2^(993 - 1023) * 1.0001001011100000101111101000001001101101011010010101 = 0.000000001.

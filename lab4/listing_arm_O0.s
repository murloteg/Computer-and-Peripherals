CalcSin(int, double):
        push    {r7} // сначала sp -= 4; помещение регистра r7 на вершину стека.
        sub     sp, sp, #52 // sp = sp - 52.
        add     r7, sp, #0 // r7 = sp + 0.
        str     r0, [r7, #12] // в регистр r0 загружается значение, лежащее по адресу (r7 + 12) [number].
        vstr.64 d0, [r7] // по адресу (r7) помещается значение из регистра d0 [argument].
        mov     r2, #0 // в регистр r2 копируется значение 0.
        mov     r3, #0 // в регистр r3 копируется значение 0.
        strd    r2, [r7, #40] // по адресу (r7 + 40) помещается значение из регистра r2 [result = 0].
        movs    r3, #1 // в регистр r3 копируется значение 1.
        str     r3, [r7, #36] // по адресу (r7 + 36) помещается значение из регистра r3 [signStatus = 1].
        mov     r2, #0 // в регистр r2 копируется значение 0.
        mov     r3, #0 // в регистр r3 копируется значение 0.
        movt    r3, 16368 // записывает в регистр r3 верхнюю половину (16 бит) 32-битного значения 16368.
        strd    r2, [r7, #24] // по адресу (r7 + 24) помещается значение из регистра r2 [nextMultiplier = 0].
        movs    r3, #1 // в регистр r3 копируется значение 1.
        str     r3, [r7, #20] // по адресу (r7 + 20) помещается значение из регистра r2 [factorial = 1].
        movs    r3, #0 // в регистр r3 копируется значение 0.
        str     r3, [r7, #16] // по адресу (r7 + 16) помещается значение из регистра r3 [i = 0].
        b       .L2 // переход на метку .L2.
.L3:
        ldr     r3, [r7, #20] // в r3 загружается значение, лежащее по адресу (r7 + 20) [factorial].
        vmov    s15, r3 @ int // в регистр s15 копируется 32-битное значение из r3 [factorial].
        vcvt.f64.s32    d17, s15 // в d17 записывается (double) s15 (преобразование одинарной точности в двойную).
        vldr.64 d18, [r7] // в регистр d18 загружается значение, лежащее по адресу (r7) [argument].
        vdiv.f64        d16, d18, d17 // d16 = d18 / d17 [argument / factorial].
        vldr.64 d17, [r7, #24] // в d17 загружается значение, лежащее по адресу (r7 + 24) [новый nextMultiplier].
        vmul.f64        d16, d17, d16 // d16 = d17 * d16 [(argument / factorial) * nextMultiplier].
        vstr.64 d16, [r7, #24] // по адресу (r7 + 24) помещается значение d16 [(argument / factorial) * nextMultiplier].
        ldr     r3, [r7, #20] // в r3 загружается значение, лежащее по адресу (r7 + 20) [factorial].
        adds    r3, r3, #1 // r3 = r3 + 1 [factorial += 1].
        str     r3, [r7, #20] // по адресу (r7 + 20) помещается значение r3 [новый factorial].
        ldr     r3, [r7, #36] // в r3 загружается значение, лежащее по адресу (r7 + 36) [signStatus].
        vmov    s15, r3 @ int // в регистр s15 копируется 32-битное значение из r3 [signStatus].
        vcvt.f64.s32    d17, s15 // в d17 записывается (double) s15 (преобразование одинарной точности в двойную).
        vldr.64 d16, [r7, #24] // в регистр d16 загружается значение, лежащее по адресу (r7 + 24) [nextMultiplier].
        vmul.f64        d16, d17, d16 // d16 = d17 * d16 [signStatus * nextMultiplier].
        vldr.64 d17, [r7, #40] // в регистр d17 загружается значение, лежащее по адресу (r7 + 40) [result].
        vadd.f64        d16, d17, d16 // d16 = d17 + d16 [result + signStatus * nextMultiplier].
        vstr.64 d16, [r7, #40] // по адресу (r7 + 40) помещается значение из d16 [новый result].
        ldr     r3, [r7, #20] // в r3 загружается значение, лежащее по адресу (r7 + 20) [factorial].
        vmov    s15, r3 @ int // в регистр s15 копируется 32-битное значение из r3 [factorial].
        vcvt.f64.s32    d17, s15 // в d17 записывается (double) s15 (преобразование одинарной точности в двойную).
        vldr.64 d18, [r7] // в регистр d18 загружается значение, лежащее по адресу (r7) [argument].
        vdiv.f64        d16, d18, d17 // d16 = d18 / d17 [argument / factorial].
        vldr.64 d17, [r7, #24] // в регистр d17 загружается значение, лежащее по адресу (r7 + 24) [nextMultiplier].
        vmul.f64        d16, d17, d16 // d16 = d17 * d16 [(argument / factorial) * nextMultiplier].
        vstr.64 d16, [r7, #24] // по адресу (r7 + 24) помещается значение из d16 [новый nextMultiplier].
        ldr     r3, [r7, #20] // в r3 загружается значение, лежащее по адресу (r7 + 20) [factorial].
        adds    r3, r3, #1 // r3 = r3 + 1 [factorial += 1].
        str     r3, [r7, #20] // по адресу (r7 + 20) помещается значение r3 [новый factorial].
        ldr     r3, [r7, #36] // в r3 загружается значение, лежащее по адресу (r7 + 36) [signStatus].
        rsbs    r3, r3, #0 // r3 = 0 - r3 (reverse substract) [signStatus *= -1].
        str     r3, [r7, #36] // по адресу (r7 + 36) помещается значение r3 [новый signStatus].
        ldr     r3, [r7, #16] // в r3 загружается значение, лежащее по адресу (r7 + 16) [i].
        adds    r3, r3, #1 // r3 = r3 + 1 [i += 1].
        str     r3, [r7, #16] // по адресу (r7 + 16) помещается значение r3 [новое значение i].
.L2:
        ldr     r2, [r7, #16] // в r2 загружается значение, лежащее по адресу (r7 + 16) [i].
        ldr     r3, [r7, #12] // в r3 загружается значение, лежащее по адресу (r7 + 12) [number].
        cmp     r2, r3 // сравнение i и number: (i - number = 0) [обновление флагов].
        blt     .L3 // если i < number, то переход на метку .L3.
        ldrd    r2, [r7, #40] // TODO: continue.
        vmov    d16, r2, r3
        vmov.f64        d0, d16
        adds    r7, r7, #52
        mov     sp, r7
        ldr     r7, [sp], #4
        bx      lr
.LC0:
        .ascii  "too few arguments. try again\000"
.LC1:
        .ascii  "too many arguments. try again\000"
.LC2:
        .ascii  "%lf\012\000"
.LC3:
        .ascii  "(clock_gettime) total time: %lf sec.\012\000"
main:
        push    {r7, lr} // сначала sp -= 8; помещение lr и r7 на стек.
        sub     sp, sp, #40 // sp = sp - 40.
        add     r7, sp, #0 // r7 = sp + 0.
        str     r0, [r7, #4] // по адресу (r7 + 4) помещается значение, лежащее в r0 [argc].
        str     r1, [r7] // по адресу (r7) помещается значение, лежащее в r1 [argv].
        ldr     r3, [r7, #4] // в регистр r3 загружается значение, лежащее по адресу (r7 + 4) [argc].
        cmp     r3, #2 // сравнение значения из r3 [argc] со значением 2 [обновление флагов] [argc - 2 == 0].
        bgt     .L6 // если argc > 2, то переход на метку .L6 [Z == 0 && V == N].
        movw    r0, #:lower16:.LC0 // записывает в регистр r0 нижнюю половину (16 бит) 32-битного значения.
        movt    r0, #:upper16:.LC0 // записывает в регистр r0 верхнюю половину (16 бит) 32-битного значения.
        bl      puts // вызов функции puts; в lr помещается адрес возврата.
        movs    r3, #0 // в регистр r3 помещается число 0 [код возврата из функции main] + обновление флагов.
        b       .L9 // переход на метку .L9.
.L6:
        ldr     r3, [r7, #4] // в регистр r3 загружается значение, лежащее по адресу (r7 + 4) [argc].
        cmp     r3, #3 // сравнение значения из r3 [argc] и 3. [обновление флагов] [argc - 3 == 0].
        ble     .L8 // если argc <= 3 [Z == 1 || N != V], то переход на метку .L8.
        movw    r0, #:lower16:.LC1 // записывает в регистр r0 нижнюю половину (16 бит) 32-битного значения.
        movt    r0, #:upper16:.LC1 // записывает в регистр r0 верхнюю половину (16 бит) 32-битного значения.
        bl      puts // вызов функции puts; в lr помещается адрес возврата.
        movs    r3, #0 // в регистр r3 помещается число 0 [код возврата из функции main] + обновление флагов.
        b       .L9 // переход на метку .L9.
.L8:
        ldr     r3, [r7] // в регистр r3 загружается значение [32 бита], лежащее по адресу (r7) [argv].
        adds    r3, r3, #4 // r3 = r3 + 4 [argv[0] + 4 = argv[1]].
        ldr     r3, [r3] // разыменование указателя, теперь тут argv[1].
        movs    r2, #10 // в регистр r2 копируется значение 10.
        movs    r1, #0 // в регистр r1 копируется значение 0 [NULL].
        mov     r0, r3 // в регистр r0 копируется значение из регистра r3 [argv[1]].
        bl      strtol // вызов функции strtol.
        str     r0, [r7, #36] // по адресу (r7 + 36) помещается значение из r0 [number -> результат работы strtol].
        ldr     r3, [r7] // в регистр r3 загружается значение, лежащее по адресу (r7) [argv].
        adds    r3, r3, #8 // r3 = r3 + 8 [argv[0] + 8 = argv[2]].
        ldr     r3, [r3] // разыменование указателя, теперь тут argv[2].
        movs    r1, #0 // в регистр r1 копируется значение 0.
        mov     r0, r3 // в регистр r0 копируется значение из r3 [argv[2]].
        bl      strtod // вызов функции strtod.
        vstr.64 d0, [r7, #24] // по адресу (r7 + 24) помещается значение из d0 [argument -> результат работы strtod].
                              // здесь .64 - спецификатор размера данных для 64-битного доступа к памяти.
        add     r3, r7, #16 // r3 = r7 + 16 [адрес start_clock].
        mov     r1, r3 // в r1 копируется значение из регистра r3 [адрес start_clock].
        movs    r0, #4 // в r0 копируется значение 4 (CLOCK_MONOTONIC_RAW).
        bl      clock_gettime // вызов функции clock_gettime.
        vldr.64 d16, [r7, #24] // в регистр d16 загружается значение, лежащее по адресу (r7 + 24) [argument].
        vldr.64 d17, .L10 // в регистр d17 загружается значение, лежащее по метке .L10 [0.017453].
        vmul.f64        d16, d16, d17 // d16 = d16 * d17 (векторное умножение) [argument * 0.017453].
        vmov.f64        d0, d16 // в регистр d0 копируется значение из d16 [argument * 0.017453].
        ldr     r0, [r7, #36] // в регистр r0 загружается значение, лежащее по адресу (r7 + 36) [number].
        bl      CalcSin(int, double) // вызов функции CalcSin.
        vmov    r2, r3, d0 // TODO: continue.
        movw    r0, #:lower16:.LC2
        movt    r0, #:upper16:.LC2
        bl      printf
        add     r3, r7, #8
        mov     r1, r3
        movs    r0, #4
        bl      clock_gettime
        ldr     r2, [r7, #8]
        ldr     r3, [r7, #16]
        subs    r3, r2, r3
        vmov    s15, r3 @ int
        vcvt.f64.s32    d17, s15
        ldr     r2, [r7, #12]
        ldr     r3, [r7, #20]
        subs    r3, r2, r3
        vmov    s15, r3 @ int
        vcvt.f64.s32    d16, s15
        vldr.64 d18, .L10+8
        vmul.f64        d16, d16, d18
        vadd.f64        d16, d17, d16
        vmov    r2, r3, d16
        movw    r0, #:lower16:.LC3
        movt    r0, #:upper16:.LC3
        bl      printf
        movs    r3, #0
.L9:
        mov     r0, r3 // копирует значение из r3 [код возврата из функции main] в r0.
        adds    r7, r7, #40 // r7 = r7 + 40.
        mov     sp, r7 // копирует значение из r7 в sp.
        pop     {r7, pc} // извлекает со стека два значения и помещает их в r7 и pc; затем sp += 8.
.L10: // quadruple-precision floating-point format.
        .word   14568529 // 00000000110111100100110001010001
        .word   1066524467 // 00111111100100011101111100110011
        .word   -400107883 // 11101000001001101101011010010101
        .word   1041313291 // 00111110000100010010111000001011
      // Эта константа будет равна: (-1)^0 * 2^(222 - 16383) * 1.0100110001010001001111111001000111011111001100111110100000100110110101101001010100111110000100010010111000001011 = 0.017453.
// 0 000000011011110 0100110001010001001111111001000111011111001100111110100000100110110101101001010100111110000100010010111000001011
